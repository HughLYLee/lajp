= Example =

== 文章简介 ==

本文通过程序样例来介绍LAJP中PHP和Java之间的的数据转换。

== PHP序列化数据简介 ==

在PHP语言中，数据类型是隐匿的，并且是根据上下文而自动变化的，比如：

{{{
$a = 10;
$a = "a is " . $a;
}}}

在第一行中，$a是int类型，在第二行中$a变化为string类型。通常“弱”类型语言，像Javascript,VB,PHP等都是这样。PHP中提供了一些函数（is_array()、is_bool()、is_float()、is_integer()等）来获得变量的类型，更直接的方式是观察变量序列化后的排列规则:

----

{{{
$a = 10;
echo serialize($a);
}}}

输出：

{{{
i:10;
}}}

i表示int类型，10是其值。

----

{{{
$a = "abcd";
echo serialize($a);
}}}

输出：

{{{
s:4:"abcd";
}}}

s表示string类型，4表示长度，"abcd"是其值。

----

{{{
$a = TRUE;
echo serialize($a);
}}}

输出：

{{{
b:1;
}}}

b表示boolean类型，1表示TRUE，0表示FALSE。

----

{{{
$a = 10.24;
echo serialize($a);
}}}

输出：

{{{
d:10.2400000000000002131628207280300557613372802734375;
}}}

d表示double类型，10.2400000000000002131628207280300557613372802734375是其值。

----

数组、对象等复杂类型也可以：

{{{
$a = array();
$a[] = 20;
$a[] = "abcde";
$a[] = TRUE;

echo serialize($a);
}}}

输出：

{{{
a:3:{i:0;i:20;i:1;s:5:"abcde";i:2;b:1;}
}}}

开始的a表示array，紧跟着的3表示数组长度，{}内部是数组元素：
 * {{{i:0;i:20;}}}是第一个元素，i:0;是KEY（表示下标是int类型的0），i:20;是VALUE。
 * {{{i:1;s:5:"abcde";}}}是第二个元素，i:1;是KEY（表示下标是int类型的1），s:5:"abcde";是VALUE。
 * {{{i:2;b:1;}}}是第三个元素，i:2;是KEY（表示下标是int类型的2），b:1;是VALUE。

{{{
$a = array();
$a["a"] = 20;
$a["b"] = "abcde";
$a["c"] = TRUE;

echo serialize($a);
}}}

输出：

{{{
a:3:{s:1:"a";i:20;s:1:"b";s:5:"abcde";s:1:"c";b:1;}
}}}

这里数组下标是字符串，数据结构可以看作是其他语言的Hashtable类型。

----

在LAJP中，PHP和Java之间传输的数据封装形式，即是上面这种PHP序列化数据形式。


== Example 1 ==

----

Java:
{{{
package aaa.bbb.ccc;
public class MyClass1
{
	public static final int myMethod1(int i)
	{
		return ++i;
	}
}
}}}


PHP:
{{{
$a = 10;
echo "a---&gt;" . serialize($a) . "&lt;---<br/>";

$b = lajp_call("aaa.bbb.ccc.MyClass1::myMethod1", $a);

echo "b---&gt;" . serialize($b) . "&lt;---<br/>";
echo "b---&gt;" . $b . "&lt;---<br/>";
}}}

输出:
{{{
a--->i:10;<---
b--->i:11;<---
b--->11<---
}}}

在LAJP中，当PHP将整形10传给Java服务时，传送的数据即是字符串{{{i:10;}}}，Java服务返回整形11也包装为字符串{{{i:11;}}}。

----

Java:
{{{
package aaa.bbb.ccc;
public class MyClass1
{
	public static final int myMethod2(long i)
	{
		return (int)++i;
	}
}
}}}


PHP:
{{{
$a = 10;
echo "a---&gt;" . serialize($a) . "&lt;---<br/>";

$b = lajp_call("aaa.bbb.ccc.MyClass1::myMethod2", $a);

echo "b---&gt;" . serialize($b) . "&lt;---<br/>";
echo "b---&gt;" . $b . "&lt;---<br/>";
}}}

输出:
{{{
a--->i:10;<---

Fatal error: Uncaught exception 'Exception' with message '[LAJP Error] Response receive Java exception: MethodNotFoundException: Can't match method: aaa.bbb.ccc.MyClass1.myMethod2(long)' in /media/sda3/prog/eclipse_php/workspace/LAJP_test/php_java.php:215 Stack trace: #0 /media/sda3/prog/eclipse_php/workspace/LAJP_test/test1_02.php(8): lajp_call('aaa.bbb.ccc.MyC...', 10) #1 {main} thrown in /media/sda3/prog/eclipse_php/workspace/LAJP_test/php_java.php on line 215
}}}

myMethod2方法参数声明为long，在PHP中没有与之对应的数据类型，因此抛出异常。

_也有朋友认为应该允许这种情况，因为在Java中int可以自动转换为long；我的意见还是不允许，因为有带来二义性的可能。_

----

Java:
{{{
package aaa.bbb.ccc;
public class MyClass1
{
	public static final int myMethod3(Integer i)
	{
		return (int)++i;
	}
}
}}}


PHP:
{{{
$a = 10;
echo "a---&gt;" . serialize($a) . "&lt;---<br/>";

$b = lajp_call("aaa.bbb.ccc.MyClass1::myMethod3", $a);

echo "b---&gt;" . serialize($b) . "&lt;---<br/>";
echo "b---&gt;" . $b . "&lt;---<br/>";
}}}

输出:
{{{
a--->i:10;<---

Fatal error: Uncaught exception 'Exception' with message '[LAJP Error] Response receive Java exception: MethodNotFoundException: Can't match method: aaa.bbb.ccc.MyClass1.myMethod3(java.lang.Integer)' in /media/sda3/prog/eclipse_php/workspace/LAJP_test/php_java.php:215 Stack trace: #0 /media/sda3/prog/eclipse_php/workspace/LAJP_test/test1_03.php(8): lajp_call('aaa.bbb.ccc.MyC...', 10) #1 {main} thrown in /media/sda3/prog/eclipse_php/workspace/LAJP_test/php_java.php on line 215
}}}

myMethod3方法参数声明为Integer，此类也不允许。

所以，在LAJP中如果PHP传送int，Java方法必声明为基本类型int；传double，必声明为基本类型double；传boolean，必声明为基本类型boolean。

----

Java:
{{{
package aaa.bbb.ccc;
public class MyClass1
{
	public static final long myMethod4(int i)
	{
		return ++i;
	}
}
}}}


PHP:
{{{
$a = 10;
echo "a---&gt;" . serialize($a) . "&lt;---<br/>";

$b = lajp_call("aaa.bbb.ccc.MyClass1::myMethod4", $a);

echo "b---&gt;" . serialize($b) . "&lt;---<br/>";
echo "b---&gt;" . $b . "&lt;---<br/>";
}}}

输出:
{{{
a--->i:10;<---
b--->O:14:"java_lang_Long":0:{}<---

Catchable fatal error: Object of class __PHP_Incomplete_Class could not be converted to string in /media/sda3/prog/eclipse_php/workspace/LAJP_test/test1_04.php on line 11
}}}

这里myMethod4方法返回类型为long，在PHP中并没有与之对应的数据类型，但PHP端仍然接收到了

{{{
O:14:"java_lang_Long":0:{}
}}}

其中起始的"O"表示这是一个对象。

在Java端，LAJP是这样来转换返回数据的：

 * 如果方法返回类型是int或包装类Integer，封装为PHP的int序列化数据；
 * 如果是double包装类Integer，封装为PHP的float序列化数据；
 * 如果是boolean包装类Boolean，封装为PHP的boolean序列化数据；
 * 如果是java.lang.String，封装为PHP的String序列化数据；
 * 如果是java.util.List或其子类，封装为PHP的array序列化数据，array下标为递增整数；
 * 如果是java.util.Map或其子类，封装为PHP的array序列化数据，array下标为字符串；
 * 如果以上都不是，视为JavaBean，封装为PHP4的对象序列化数据。

本例中，long被视为最后一种情况。

----
